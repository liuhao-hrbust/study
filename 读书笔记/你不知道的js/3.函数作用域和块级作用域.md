# 函数作用域和块级作用域

## 隐藏内部实现

**最小特权原则**：在软件设计中，应该最小限度地暴露必要内容，而将其他内容都隐藏起来。
如果所有变量和函数都在全局作用域中，会破坏最小特权原则，因为他们可能会被以非预期的方式使用。

隐藏带来的另一个好处，是可以避免同名标识符之间的冲突。在全局作用域中，当程序加载了多个第三方库时，如果它们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突。

这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象 被用作库的 命名空间 ， 所有需要暴露给外界的功能都会成为这个对象（命名空间）的属 性，而不是将自己的标识符暴漏在顶级的词法作用域中。**如 jQuery 的\$。**

## 使用函数作用域

我们可以在任意代码片段外添加包装函数，可以将内部的变量和函数定义隐藏起来，外部作用域无法访问包装函数内部的任何内容，但这种方式仍然会声明一个具名函数，具名函数的函数名本身也污染了所在作用域，同时，必须显式地通过函数名调用这个函数才能运行其中的代码。

js 提供了能够同时解决以上两个问题的方案：**立即执行函数表达式**

```js
var a = 2;
(function foo() {
    // <-- 添加这一行

    var a = 3;
    console.log(a); // 3
})(); // <-- 以及这一行

console.log(a); // 2
```

首先，包装函数的声明以 (function... 而不仅是以 function... 开始。尽管看上去这并不 是一个很显眼的细节，但实际上却是非常重要的区别。函数会被当作函数表达式而不是一个标准的函数声明来处理。

> 区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位 置（不仅仅是一行代码，而是整个声明中的位置）。如果 function 是声明中 的第一个词，那么就是一个函数声明，否则就是一个函数表达式。

### 立即执行函数表达式

```js
var a = 2;
(function foo() {
    // <-- 添加这一行

    var a = 3;
    console.log(a); // 3
})(); // <-- 以及这一行

console.log(a); // 2
```

相较于传统的 IIFE 形式，很多人都更喜欢另一个改进的形式： (function(){ .. }()) 。

## 块作用域

```js
for (var i = 0; i < 10; i++) {
    console.log(i);
}
```

对于常规的变量提升的方式而言，即使在代码块中声明的变量，也只会受到函数作用域的限制，根据最小特权原则的思想，如果有一个更小的作用域（代码块级别）可以更好地避免命名空间污染。

### let

let 关键字可以将变量绑定到所在的任意作用域中（通常是 { .. } 内部）。换句话说， let为其声明的变量隐式地绑定了所在的块作用域。

为块作用域显式地创建块可以部分解决这个问题，使变量的附属关系变得更加清晰。通常 来讲，显式的代码优于隐式或一些精巧但不清晰的代码。显式的块作用域风格非常容易书 写，并且和其他语言中块作用域的工作原理一致，除此之外，如果需要对其进行重构，整个块都可以被方便地移动而不会对外部 if 声明的位置和语义产生任何影响。
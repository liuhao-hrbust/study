# 提升

JavaScript 代码并不是从上至下依次执行的。

```js
a = 2;
var a;
console.log(a); // 2
```

变量声明写在赋值之后，但声明不会将 a 的值重置为 undefined。

## 编译器

引擎会在解释 JavaScript 代码之前首先对其进行编译。编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。

因此，正确的思考思路是，包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。

当你看到 var a = 2; 时，可能会认为这是一个声明。但 JavaScript 实际上会将其看成两个声明： var a; 和 a = 2; 。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行阶段。

因此，这个过程就好像变量和函数声明从它们在代码中出现的位置被移动到了最上面。这个过程叫作**提升**。

---

需要注意的是，**函数声明会被提升，但是函数表达式不会被提升。**

> 区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位 置（不仅仅是一行代码，而是整个声明中的位置）。如果 function 是声明中 的第一个词，那么就是一个函数声明，否则就是一个函数表达式。

```JS

foo(); // 不是 ReferenceError, 而是 TypeError!

var foo = function bar() { // ...

};
```

上面的代码中，在 foo 被赋值前调用了 foo，相当于调用了 undefined，所以引擎会抛出 TypeError 异常。

---

## 函数优先

函数声明和变量声明都会被提升。但是一个值得注意的细节是函数会首先被提升，然后才是变量。

```js
foo(); // 1

var foo;
function foo() {
    console.log(1);
}

foo = function () {
    console.log(2);
};
```

这里会输出 1 而不是 2，这段代码会被引擎理解为如下形式：

```js
function foo() {
    console.log(1);
}

foo(); // 1

foo = function () {
    console.log(2);
};
```

注意， var foo 尽管出现在 function foo()... 的声明之前，但它是重复的声明（因此被忽略了），因为函数声明会被提升到普通变量之前。
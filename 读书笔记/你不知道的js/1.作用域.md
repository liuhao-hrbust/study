# 作用域是什么

存储变量，并且之后可以方便地找到这些变量。这套规则被称为作用域。

## 1.2 理解作用域

- 引擎
    从头到尾负责整个js程序的编译及执行过程
- 编译器
    负责语法分析及代码生成
- 作用域
    负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

### var a = 2; 编译器的工作过程

1. 遇到 var a，编译器会询问当前作用域，是否经存在这一变量，如果存在，则忽略这一声明，继续进行编译；否则编译器会要求作用域在当前作用域的集合中声明一个新的变量，命名为a

2. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值操作。 引擎运行时会首先询问作用域， 在当前的作用域集合中是否存在一个叫作 a 的变量。 如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量

总结：变量赋值前会进行两个操作

1. 在作用域中查找该变量，如果不存在且有变量声明语句则声明一个新的变量
2. 在找到该变量后对它进行赋值

### 1.2.3 引擎如何查找变量

在编译器为引擎生成代码后，引擎执行响应代码，遇到变量时会通过作用域查找该变量，其中有两种查找方式：LHS查询和RHS查询

- LHS查询：找到容器的本身，可以对其进行赋值（写）
- RHS查询：找到该变量的值（读）

### 1.2.5 小测验

```js
function foo(a) {
    var b = a;
    return a + b;
}

var c = foo( 2 );
```

找到其中所有的LHS 和 RHS 查询

1. 找出所有的 LHS 查询（这里有3处！）

c = ..; 、 a = 2 （隐式变量分配）、 b = ..

2. 找出所有的 RHS 查询（这里有 4 处！）

foo (2.. 、 = a ; 、 a .. 、 .. b

## 1.3 作用域嵌套

当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。
遍历嵌套作用域链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到， 就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都 会停止。

## 1.4 异常

如果RHS查询在所有嵌套的作用域中找不到所需的变量，引擎会抛出ReferenceError异常。

对于LHS查询，如果在顶层中也没有找到目标变量，全局作用域就会创建一个具有该名称的变量（非严格模式下）并将其返还给引擎。

在严格模式下，进行LHS查询，即对未声明变量赋值等操作时，引擎会抛出ReferenceError异常。

总结：不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式 地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛 出 ReferenceError 异常（严格模式下）。